<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ESP32 遠端雙向語音 + 相機</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      background: #111;
      color: #fff;
      text-align: center;
      padding: 20px;
    }
    video, img {
      max-width: 100%;
      border-radius: 12px;
      background: #000;
    }
    button {
      font-size: 16px;
      padding: 10px 20px;
      margin: 10px;
      border-radius: 8px;
      border: none;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h2>ESP32 遠端雙向語音 + 相機控制</h2>
  <img id="cam" src="" alt="ESP32 Cam Stream">
  <div>
    <button onclick="startMic()">🎙️ 開始雙向語音</button>
    <button onclick="stopMic()">🛑 停止語音</button>
    <button onclick="shot()">📸 快照</button>
  </div>

<script>
let ws, audioCtx, micNode, srcNode, running = false;
const SR = 16000;
let imageBuffer = []; // ⬅️ 用來暫存 JPEG 快照資料

async function ensureCtx() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SR });
    if (audioCtx.state === 'suspended') {
      try { await audioCtx.resume(); } catch (e) {}
    }

    const blob = new Blob([`
      class PCMProcessor extends AudioWorkletProcessor {
        constructor() {
          super(); this.acc = []; this.target = 1024;
        }
        process(inputs, outputs) {
          const input = inputs[0], output = outputs[0];
          if (!input || !input.length) return true;
          const ch0 = input[0];
          if (!ch0) return true;
          output[0].set(ch0);
          this.acc.push(...ch0);
          while (this.acc.length >= this.target) {
            const s = this.acc.splice(0, this.target);
            const pcm = new Int16Array(s.length);
            for (let i = 0; i < s.length; i++) {
              let v = Math.max(-1, Math.min(1, s[i]));
              pcm[i] = v < 0 ? v * 0x8000 : v * 0x7FFF;
            }
            this.port.postMessage(pcm.buffer, [pcm.buffer]);
          }
          return true;
        }
      }
      registerProcessor('pcm-processor', PCMProcessor);
    `], { type: 'application/javascript' });
    const url = URL.createObjectURL(blob);
    await audioCtx.audioWorklet.addModule(url);
  }
}

async function startMic() {
  if (running) return;
  running = true;
  await ensureCtx();
  await audioCtx.resume();

  ws = new WebSocket("wss://esp32-server-st33.onrender.com/toPhone");
  ws.binaryType = "arraybuffer";

  ws.onmessage = async (event) => {
    let ab = event.data;
    if (!(ab instanceof ArrayBuffer)) {
      if (ab?.arrayBuffer) ab = await ab.arrayBuffer();
      else return;
    }

    const u8 = new Uint8Array(ab);

    // 📷 偵測是否為 JPEG 開頭
    if (u8[0] === 0xFF && u8[1] === 0xD8) {
      imageBuffer = [u8];
      return;
    }

    // 📷 若正在組合 JPEG（已收到開頭）
    if (imageBuffer.length > 0) {
      imageBuffer.push(u8);

      const len = u8.length;
      if (len >= 2 && u8[len - 2] === 0xFF && u8[len - 1] === 0xD9) {
        const totalLen = imageBuffer.reduce((acc, part) => acc + part.length, 0);
        const full = new Uint8Array(totalLen);
        let offset = 0;
        for (const part of imageBuffer) {
          full.set(part, offset);
          offset += part.length;
        }
        const blob = new Blob([full], { type: "image/jpeg" });
        document.getElementById("cam").src = URL.createObjectURL(blob);
        imageBuffer = [];
        console.log("📸 顯示快照成功，總長度:", totalLen);
        return;
      }
      return;
    }

    // 🎧 播放音訊資料
    if (!ab || ab.byteLength < 2) return;
    const pcm16 = new Int16Array(ab);
    const f32 = new Float32Array(pcm16.length);
    for (let i = 0; i < pcm16.length; i++) f32[i] = pcm16[i] / 32768.0;
    const buf = audioCtx.createBuffer(1, f32.length, SR);
    buf.copyToChannel(f32, 0);
    const src = audioCtx.createBufferSource();
    src.buffer = buf;
    src.connect(audioCtx.destination);
    src.start();
  };

  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
  srcNode = audioCtx.createMediaStreamSource(stream);
  micNode = new AudioWorkletNode(audioCtx, "pcm-processor", {
    numberOfInputs: 1,
    numberOfOutputs: 1,
    outputChannelCount: [1]
  });
  const sink = audioCtx.createGain();
  sink.gain.value = 0.0;
  micNode.connect(sink).connect(audioCtx.destination);
  srcNode.connect(micNode);

  micNode.port.onmessage = (ev) => {
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(ev.data);
    }
  };
}

function stopMic() {
  running = false;
  try { srcNode && srcNode.disconnect(); } catch (_) {}
  try { micNode && micNode.disconnect(); } catch (_) {}
  try { ws && ws.readyState === WebSocket.OPEN && ws.close(); } catch (_) {}
}

function shot() {
  ws && ws.readyState === WebSocket.OPEN && ws.send("SNAPSHOT");
}
</script>
</body>
</html>
