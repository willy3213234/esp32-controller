<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ESP32 é›™ WebSocket æ§åˆ¶é </title>
  <style>
    body { font-family: system-ui, sans-serif; background: #111; color: #fff; text-align: center; padding: 20px; }
    img { width: 100%; max-width: 480px; background: #000; border-radius: 12px; }
    button { margin: 10px; padding: 10px 20px; font-size: 16px; border-radius: 8px; cursor: pointer; }
  </style>
</head>
<body>
  <h2>ESP32 é›™å‘èªéŸ³ + ç›¸æ©Ÿä¸²æµ</h2>
  <img id="cam" alt="Camera Stream" />
  <div>
    <button onclick="startCam()">ğŸ“· å•Ÿå‹•é¡é ­</button>
    <button onclick="stopCam()">ğŸ›‘ åœæ­¢é¡é ­</button>
    <button onclick="startMic()">ğŸ™ï¸ é–‹å§‹èªéŸ³</button>
    <button onclick="stopMic()">ğŸ”‡ åœæ­¢èªéŸ³</button>
  </div>

<script type="module">
(async () => {
  const SR = 16000;
  let ws_audio, ws_video, micNode, srcNode, audioCtx;
  let camOn = false, running = false;
  let lastUrl = null;

  const camEl = document.getElementById("cam");

  function connectSockets() {
    ws_audio = new WebSocket("wss://esp32-server-st33.onrender.com/toPhone/audio");
    ws_audio.binaryType = "arraybuffer";
    ws_audio.onmessage = (event) => {
      const raw = new Uint8Array(event.data);
      if (raw[0] !== 0x02) return;
        const audioBytes = raw.slice(1);
      const pcm16 = new Int16Array(audioBytes.buffer); // âœ… ä¸å† offset=1
      const f32 = new Float32Array(pcm16.length);
      for (let i = 0; i < pcm16.length; i++) f32[i] = pcm16[i] / 32768;
      const buf = audioCtx.createBuffer(1, f32.length, SR);
      buf.copyToChannel(f32, 0);
      const src = audioCtx.createBufferSource();
      src.buffer = buf;
      src.connect(audioCtx.destination);
      src.start();
    };

    ws_video = new WebSocket("wss://esp32-server-st33.onrender.com/toPhone/video");
    ws_video.binaryType = "arraybuffer";
    ws_video.onmessage = (event) => {
      const raw = new Uint8Array(event.data);
      if (raw[0] !== 0x01) return;
      const blob = new Blob([raw.slice(1)], { type: "image/jpeg" });
      const url = URL.createObjectURL(blob);
      if (lastUrl) URL.revokeObjectURL(lastUrl);
      lastUrl = url;
      camEl.src = url;
    };
  }

  async function ensureAudioCtx() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SR });
    const blob = new Blob([`
      class PCMProcessor extends AudioWorkletProcessor {
        constructor() { super(); this.buf = []; this.target = 1024; }
        process(inputs) {
          const input = inputs[0]?.[0];
          if (!input) return true;
          this.buf.push(...input);
          while (this.buf.length >= this.target) {
            const out = new Int16Array(this.target);
            for (let i = 0; i < this.target; i++) {
              let s = this.buf.shift();
              out[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
            }
            this.port.postMessage(out.buffer, [out.buffer]);
          }
          return true;
        }
      }
      registerProcessor("pcm-processor", PCMProcessor);
    `], { type: "application/javascript" });
    const url = URL.createObjectURL(blob);
    await audioCtx.audioWorklet.addModule(url);
  }

  window.startMic = async () => {
    if (running) return;
    console.log("ğŸ¤ ç™¼é€ START_MIC åˆ° ESP32");
    running = true;
    await ensureAudioCtx();
    await audioCtx.resume();

    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    srcNode = audioCtx.createMediaStreamSource(stream);
    micNode = new AudioWorkletNode(audioCtx, "pcm-processor", {
    numberOfInputs: 1,
    numberOfOutputs: 1,
    outputChannelCount: [1]
  });
    micNode.port.onmessage = (ev) => {
      if (ws_audio?.readyState === 1) {
        const audioBuf = new Uint8Array(ev.data.byteLength + 1);
        audioBuf[0] = 0x02;
        audioBuf.set(new Uint8Array(ev.data), 1);
        ws_audio.send(audioBuf);
      }
    };
    const silent = audioCtx.createGain(); silent.gain.value = 0;
    micNode.connect(silent).connect(audioCtx.destination);
    srcNode.connect(micNode);

    ws_audio?.send("START_MIC");
  };

  window.stopMic = () => {
    console.log("ğŸ”‡ ç™¼é€ STOP_MIC åˆ° ESP32");
    running = false;
    try { srcNode?.disconnect(); } catch (_) {}
    try { micNode?.disconnect(); } catch (_) {}
    ws_audio?.send("STOP_MIC");
  };

  window.startCam = () => {
    camOn = true;
    if (ws_video?.readyState === 1) {
      ws_video.send("START_CAM");
      console.log("ğŸ“· ç™¼é€ START_CAM åˆ° ESP32");
    } else {
      console.warn("âš ï¸ ws_video å°šæœªé€£ç·šï¼Œç„¡æ³•å•Ÿç”¨é¡é ­");
    }
  };

  window.stopCam = () => {
    camOn = false;
    if (ws_video?.readyState === 1) {
      ws_video.send("STOP_CAM");
      console.log("ğŸ›‘ ç™¼é€ STOP_CAM åˆ° ESP32");
    }
  };

  connectSockets();
})();
</script>
</body>
</html>
