<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ESP32 é ç«¯æ§åˆ¶é¢æ¿</title>
  <style>
    body { font-family: system-ui, sans-serif; background: #111; color: #fff; padding: 20px; display: flex; gap: 40px; flex-wrap: wrap; }
    section { flex: 1 1 400px; background: #222; border-radius: 16px; padding: 20px; }
    h2 { margin-top: 0; }
    img, video, canvas { width: 100%; max-width: 480px; background: #000; border-radius: 12px; display: block; margin: 10px auto; }
    button { margin: 5px; padding: 10px 20px; font-size: 16px; border-radius: 8px; cursor: pointer; }
  </style>
</head>
<body>

<!-- ğŸ™ï¸ğŸ¥ ESP32-S3ï¼šé›™å‘èªéŸ³ + ç›¸æ©Ÿä¸²æµ -->
<section>
  <h2>ESP32-S3 ğŸ™ï¸ é›™å‘èªéŸ³ + ğŸ“¸ ç›¸æ©Ÿä¸²æµ</h2>
  <img id="cam" alt="Camera Stream" />
  <div>
    <button onclick="startCam()">ğŸ“· å•Ÿå‹•é¡é ­</button>
    <button onclick="stopCam()">ğŸ›‘ åœæ­¢é¡é ­</button>
    <button onclick="startMic()">ğŸ™ï¸ é–‹å§‹èªéŸ³</button>
    <button onclick="stopMic()">ğŸ”‡ åœæ­¢èªéŸ³</button>
  </div>
</section>

<!-- ğŸ“±ğŸ“¤ æ‰‹æ©Ÿå½±åƒ âœ ESP32-LCD é¡¯ç¤º -->
<section>
  <h2>ğŸ“± æ‰‹æ©Ÿå½±åƒ âœ ğŸ–¥ï¸ ESP32-LCD é¡¯ç¤º</h2>
  <video id="v" playsinline muted></video>
  <canvas id="c" style="display:none"></canvas>
  <div>
    <button id="startLcd">é–‹å§‹å‚³é€</button>
  </div>
</section>

<script type="module">
(async () => {
  // ======================== ğŸ™ï¸ éŸ³è¨Š + ç›¸æ©Ÿ ========================
  const SR = 16000;
  let ws_audio, ws_video, micNode, srcNode, audioCtx;
  let camOn = false, running = false;
  let lastUrl = null;
  const camEl = document.getElementById("cam");

  function connectSockets() {
    ws_audio = new WebSocket("wss://esp32-server-st33.onrender.com/toPhone/audio");
    ws_audio.binaryType = "arraybuffer";
    ws_audio.onmessage = (event) => {
      const raw = new Uint8Array(event.data);
      if (raw[0] !== 0x02) return;
      const pcm16 = new Int16Array(raw.buffer, 1);
      const f32 = new Float32Array(pcm16.length);
      for (let i = 0; i < pcm16.length; i++) f32[i] = pcm16[i] / 32768.0;
      const buf = audioCtx.createBuffer(1, f32.length, SR);
      buf.copyToChannel(f32, 0);
      const src = audioCtx.createBufferSource();
      src.buffer = buf;
      src.connect(audioCtx.destination);
      src.start();
    };

    ws_video = new WebSocket("wss://esp32-server-st33.onrender.com/toPhone/video");
    ws_video.binaryType = "arraybuffer";
    ws_video.onmessage = (event) => {
      const raw = new Uint8Array(event.data);
      if (raw[0] !== 0x01) return;
      const blob = new Blob([raw.slice(1)], { type: "image/jpeg" });
      const url = URL.createObjectURL(blob);
      if (lastUrl) URL.revokeObjectURL(lastUrl);
      lastUrl = url;
      camEl.src = url;
    };
  }

  async function ensureAudioCtx() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SR });
    const blob = new Blob([`
      class PCMProcessor extends AudioWorkletProcessor {
        constructor() { super(); this.buf = []; this.target = 1024; }
        process(inputs) {
          const input = inputs[0]?.[0];
          if (!input) return true;
          this.buf.push(...input);
          while (this.buf.length >= this.target) {
            const out = new Int16Array(this.target);
            for (let i = 0; i < this.target; i++) {
              let s = this.buf.shift();
              out[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
            }
            this.port.postMessage(out.buffer, [out.buffer]);
          }
          return true;
        }
      }
      registerProcessor("pcm-processor", PCMProcessor);
    `], { type: "application/javascript" });
    const url = URL.createObjectURL(blob);
    await audioCtx.audioWorklet.addModule(url);
  }

  window.startMic = async () => {
    if (running) return;
    running = true;
    await ensureAudioCtx();
    await audioCtx.resume();
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    srcNode = audioCtx.createMediaStreamSource(stream);
    micNode = new AudioWorkletNode(audioCtx, "pcm-processor", { numberOfInputs: 1, numberOfOutputs: 1, outputChannelCount: [1] });
    micNode.port.onmessage = (ev) => {
      if (ws_audio?.readyState === 1) {
        const audioBuf = new Uint8Array(ev.data.byteLength + 1);
        audioBuf[0] = 0x02;
        audioBuf.set(new Uint8Array(ev.data), 1);
        ws_audio.send(audioBuf);
      }
    };
    const silent = audioCtx.createGain(); silent.gain.value = 0;
    micNode.connect(silent).connect(audioCtx.destination);
    srcNode.connect(micNode);
    ws_audio?.send("START_MIC");
  };

  window.stopMic = () => {
    running = false;
    try { srcNode?.disconnect(); } catch (_) {}
    try { micNode?.disconnect(); } catch (_) {}
    ws_audio?.send("STOP_MIC");
  };

  window.startCam = () => {
    camOn = true;
    if (ws_video?.readyState === 1) ws_video.send("START_CAM");
  };

  window.stopCam = () => {
    camOn = false;
    if (ws_video?.readyState === 1) ws_video.send("STOP_CAM");
  };

  connectSockets();


  // ======================== ğŸ“± æ‰‹æ©Ÿè¦–è¨Š â†’ LCD ========================
const B_CHUNK = 1024;    
let ws_lcd, v = document.getElementById('v'), c = document.getElementById('c');
c.width = 240; c.height = 240;

async function sendFrame() {
  if (!ws_lcd || ws_lcd.readyState !== 1) return;

  const ctx = c.getContext('2d', { willReadFrequently:true });
  ctx.drawImage(v, 0, 0, c.width, c.height);

  const blob = await new Promise(r => c.toBlob(r, 'image/jpeg', 0.5));
  const buf = await blob.arrayBuffer();
  const u8 = new Uint8Array(buf);
  const L = u8.length;
  const n = Math.ceil(L / B_CHUNK);
  const id = Math.floor(Math.random() * 1e6);

  for (let ix=0; ix<n; ix++){
    const off = ix * B_CHUNK, len = Math.min(B_CHUNK, L - off);
    const frame = new Uint8Array(13+len+4);
    frame[0]=0xB1;
    frame[1]=(id>>24)&255; frame[2]=(id>>16)&255; frame[3]=(id>>8)&255; frame[4]=id&255;
    frame[5]=(ix>>8)&255; frame[6]=ix&255;
    frame[7]=(n>>8)&255; frame[8]=n&255;
    frame[9]=(L>>24)&255; frame[10]=(L>>16)&255; frame[11]=(L>>8)&255; frame[12]=L&255;
    frame.set(u8.subarray(off,off+len), 13);
    ws_lcd.send(frame);
    await new Promise(r=>setTimeout(r,5));
  }

  // ğŸŸ¢ æ”¹æˆ requestAnimationFrameï¼Œèˆ‡ç€è¦½å™¨å½±åƒæ›´æ–°åŒæ­¥
  requestAnimationFrame(sendFrame);
}

document.getElementById('startLcd').onclick = async () => {
  const stream = await navigator.mediaDevices.getUserMedia({ video:true });
  v.srcObject = stream;

  ws_lcd = new WebSocket("wss://esp32-server-st33.onrender.com/toPhone/lcd");
  ws_lcd.binaryType = 'arraybuffer';

  ws_lcd.onopen = async () => {
    await v.play(); // ğŸŸ¢ ç­‰å¾…ç›¸æ©Ÿç•«é¢çœŸçš„é–‹å§‹æ’­æ”¾
    console.log("ğŸ“¡ LCD WebSocket å·²é€£ç·šï¼Œé–‹å§‹å‚³é€");
    sendFrame();
  };
};

})();
</script>
</body>
</html>
