<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ESP32 é›™å‘èªéŸ³ + MJPEG ä¸²æµ</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 0; background: #111; color: #fff; text-align: center; padding: 20px; }
    h2 { margin-bottom: 16px; }
    img { width: 100%; max-width: 480px; border-radius: 12px; background: #000; }
    .btn { font-size: 16px; padding: 10px 20px; margin: 10px 5px; border-radius: 8px; border: none; cursor: pointer; }
    .btn:hover { background: #333; }
  </style>
</head>
<body>
  <h2>ESP32 é›™å‘èªéŸ³ + MJPEG ä¸²æµ</h2>
  <img id="cam" src="" alt="ESP32 Camera Stream" />
  <div>
    <button class="btn" onclick="startCam()">ğŸ“· å•Ÿå‹•é¡é ­</button>
    <button class="btn" onclick="stopCam()">ğŸ›‘ åœæ­¢é¡é ­</button>
    <button class="btn" onclick="startMic()">ğŸ™ï¸ é–‹å§‹èªéŸ³</button>
    <button class="btn" onclick="stopMic()">ğŸ”‡ åœæ­¢èªéŸ³</button>
  </div>

<script type="module">
(async () => {
  const SR = 16000;
  let ws, audioCtx, micNode, srcNode, lastUrl;
  let running = false;
  let camOn = false;

  const camEl = document.getElementById("cam");

  function initWebSocket() {
    ws = new WebSocket("wss://esp32-server-st33.onrender.com/toPhone");
    ws.binaryType = "arraybuffer";

    ws.onopen = () => {
      console.log("âœ… WebSocket é€£ç·šæˆåŠŸ");
      if (camOn) ws.send("START_CAM");
    };

ws.onmessage = (event) => {
  const ab = event.data;  // â† é€™è¡Œå°‘äº†ï¼Œé€™æ˜¯éŒ¯èª¤é—œéµ
  const camEl = document.getElementById("cam");
  const type = raw[0];               // è®€å–ç¬¬ä¸€å€‹ byte ä½œç‚ºæ¨™é ­
  const payload = raw.slice(1);     // å‰©ä¸‹çš„å°±æ˜¯å¯¦éš›è³‡æ–™
  if (!camEl) return;

  // é¡¯ç¤ºå½±åƒ
  if (type === 0x01) {  // ç²—ç•¥åˆ¤æ–·æ˜¯å¦ç‚ºå½±åƒ
    const blob = new Blob([ab], { type: "image/jpeg" });
    const url = URL.createObjectURL(blob);
    if (lastUrl) URL.revokeObjectURL(lastUrl);
    lastUrl = url;
    camEl.src = url;
    console.log("ğŸï¸ é¡¯ç¤ºåœ–ç‰‡", blob);
    return;
  }

  // æ’­æ”¾è²éŸ³ï¼ˆInt16 PCMï¼‰
  else if (type === 0x02) {
  const pcm16 = new Int16Array(ab);
  const f32 = new Float32Array(pcm16.length);
  for (let i = 0; i < pcm16.length; i++) f32[i] = pcm16[i] / 32768.0;
  const buf = audioCtx.createBuffer(1, f32.length, SR);
  buf.copyToChannel(f32, 0);
  const src = audioCtx.createBufferSource();
  src.buffer = buf;
  src.connect(audioCtx.destination);
  src.start();
    }
};

    ws.onclose = () => console.warn("âŒ WebSocket ä¸­æ–·");
  }

  async function ensureAudioCtx() {
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SR });
      const blob = new Blob([`
        class PCMProcessor extends AudioWorkletProcessor {
          constructor() { super(); this.buffer = []; this.target = 1024; }
          process(inputs) {
            const input = inputs[0][0];
            if (!input) return true;
            this.buffer.push(...input);
            while (this.buffer.length >= this.target) {
              const out = new Int16Array(this.target);
              for (let i = 0; i < this.target; i++) {
                let s = this.buffer.shift();
                out[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
              }
              this.port.postMessage(out.buffer, [out.buffer]);
            }
            return true;
          }
        }
        registerProcessor("pcm-processor", PCMProcessor);
      `], { type: "application/javascript" });
      const url = URL.createObjectURL(blob);
      await audioCtx.audioWorklet.addModule(url);
    }
  }

  window.startMic = async function() {
    if (running) return;
    running = true;
    await ensureAudioCtx();
    await audioCtx.resume();

    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    srcNode = audioCtx.createMediaStreamSource(stream);
    micNode = new AudioWorkletNode(audioCtx, "pcm-processor");
    micNode.port.onmessage = (ev) => {
      if (ws?.readyState === WebSocket.OPEN) ws.send(ev.data);
    };

    const silent = audioCtx.createGain(); silent.gain.value = 0;
    micNode.connect(silent).connect(audioCtx.destination);
    srcNode.connect(micNode);

    ws?.send("START_MIC");
    console.log("ğŸ™ï¸ éº¥å…‹é¢¨é–‹å§‹å‚³é€");
  };

  window.stopMic = function() {
    running = false;
    try { srcNode?.disconnect(); } catch (_) {}
    try { micNode?.disconnect(); } catch (_) {}
    ws?.send("STOP_MIC");
    console.log("ğŸ”‡ éº¥å…‹é¢¨åœæ­¢");
  };

  window.startCam = function() {
    if (ws?.readyState === WebSocket.OPEN) {
      camOn = true;
      ws.send("START_CAM");
      console.log("ğŸ“· é–‹å§‹é¡é ­");
    }
  };

  window.stopCam = function() {
    camOn = false;
    ws?.send("STOP_CAM");
    console.log("ğŸ›‘ åœæ­¢é¡é ­");
  };

  // åˆå§‹åŒ– WebSocket
  initWebSocket();
})();
</script>
</body>
</html>
