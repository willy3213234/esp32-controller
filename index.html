<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ğŸ“·ğŸ¤ ESP32 é›™å‘èªéŸ³ + MJPEG ä¸²æµ</title>
  <style>
    body { font-family: sans-serif; background: #111; color: #eee; text-align: center; }
    img { width: 100%; max-width: 640px; border-radius: 10px; background: #000; }
    button { padding: 10px 16px; margin: 10px; font-size: 16px; border-radius: 8px; }
    .status { margin: 10px 0; color: #6f6; }
  </style>
</head>
<body>
  <h2>ğŸ¥ MJPEG ä¸²æµ + ğŸ¤ é›™å‘èªéŸ³</h2>
  <img id="cam" src="http://192.168.0.78:80/stream" alt="Camera Stream" />
  <div>
    <button onclick="startMic()">ğŸ™ï¸ é–‹å§‹å‚³é€èªéŸ³</button>
    <button onclick="stopMic()">ğŸ›‘ åœæ­¢èªéŸ³</button>
  </div>
  <div class="status" id="status">ç­‰å¾…é€£ç·šä¸­...</div>

  <script>
    const statusEl = document.getElementById("status");
    const wsOut = new WebSocket("wss://esp32-server-st33.onrender.com/fromESP");
    const wsIn  = new WebSocket("wss://esp32-server-st33.onrender.com/toESP");

    let audioCtx;
    let workletNode;
    let micStream;

    // ğŸ§ æ’­æ”¾ ESP32 å‚³ä¾†çš„éŸ³è¨Š
    wsOut.binaryType = "arraybuffer";
    wsOut.onmessage = async (event) => {
      if (!audioCtx) {
        audioCtx = new AudioContext();
        await audioCtx.audioWorklet.addModule("worklet.js");
        workletNode = new AudioWorkletNode(audioCtx, "pcm-player");
        workletNode.connect(audioCtx.destination);
      }
      const pcm = new Int16Array(event.data);
      workletNode.port.postMessage(pcm);
    };

    // ğŸ™ï¸ éŒ„éŸ³ä¸¦å‚³é€éŸ³è¨Šåˆ° ESP32
    async function startMic() {
      statusEl.innerText = "ğŸ™ï¸ éŒ„éŸ³ä¸­...";
      micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      audioCtx = new AudioContext();
      const source = audioCtx.createMediaStreamSource(micStream);
      const processor = audioCtx.createScriptProcessor(1024, 1, 1);
      processor.onaudioprocess = (e) => {
        const input = e.inputBuffer.getChannelData(0);
        const pcm = new Int16Array(input.length);
        for (let i = 0; i < input.length; i++) {
          let s = input[i] * 32767;
          pcm[i] = Math.max(-32768, Math.min(32767, s));
        }
        if (wsIn.readyState === WebSocket.OPEN) {
          wsIn.send(pcm);
        }
      };
      source.connect(processor);
      processor.connect(audioCtx.destination);
    }

    function stopMic() {
      statusEl.innerText = "ğŸ›‘ éº¥å…‹é¢¨é—œé–‰";
      if (micStream) micStream.getTracks().forEach(t => t.stop());
    }

    wsOut.onopen = () => statusEl.innerText = "âœ… å½±åƒèˆ‡èªéŸ³é€£ç·šæˆåŠŸ";
    wsOut.onerror = () => statusEl.innerText = "âŒ èªéŸ³æ¥æ”¶éŒ¯èª¤";
    wsIn.onerror = () => statusEl.innerText = "âŒ èªéŸ³å‚³é€éŒ¯èª¤";
  </script>
</body>
</html>
